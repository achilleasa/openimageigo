/*

OpenImageIO bindings

https://sites.google.com/site/openimageio/home

*/
package oiio

/*
#cgo CPPFLAGS: -I./cpp
#cgo CPPFLAGS: -I/usr/local/include
#cgo LDFLAGS: -lstdc++
#cgo LDFLAGS: -L/usr/local/lib -lOpenImageIO

#include "stdlib.h"

#include "cpp/oiio.h"

*/
import "C"

import (
	"errors"
	"runtime"
	"unsafe"
)

// ImageInput abstracts the reading of an image file in a file format-agnostic manner.
type ImageInput struct {
	ptr unsafe.Pointer
}

func newImageInput(i unsafe.Pointer) *ImageInput {
	in := &ImageInput{i}
	runtime.SetFinalizer(in, deleteImageInput)
	return in
}

func deleteImageInput(i *ImageInput) {
	C.free(i.ptr)
}

// Create an ImageInput subclass instance that is able to read the given file and open it,
// returning the opened ImageInput if successful. If it fails, return error.
func OpenImageInput(filename string) (*ImageInput, error) {
	c_str := C.CString(filename)
	defer C.free(unsafe.Pointer(c_str))

	cfg := unsafe.Pointer(nil)
	ptr := C.ImageInput_Open(c_str, cfg)

	in := newImageInput(ptr)

	return in, in.LastError()
}

// Return the last error generated by API calls.
// An nil error will be returned if no error has occured.
func (i *ImageInput) LastError() error {
	err := C.GoString(C.ImageInput_geterror(i.ptr))
	if err == "" {
		return nil
	}
	return errors.New(err)
}

// Return the name of the format implemented by this image.
func (i *ImageInput) FormatName() string {
	return C.GoString(C.ImageInput_format_name(i.ptr))
}

// Close an image that we are totally done with.
func (i *ImageInput) Close() error {
	if !bool(C.ImageInput_close(i.ptr)) {
		return i.LastError()
	}
	return nil
}

// Return true if the named file is file of the type for this ImageInput.
// The implementation will try to determine this as efficiently as possible,
// in most cases much less expensively than doing a full Open().
// Note that a file can appear to be of the right type (i.e., ValidFIle() returning true)
// but still fail a subsequent call to Open(), such as if the contents of the file are
// truncated, nonsensical, or otherwise corrupted.
func (i *ImageInput) ValidFile(filename string) bool {
	c_str := C.CString(filename)
	defer C.free(unsafe.Pointer(c_str))
	return bool(C.ImageInput_valid_file(i.ptr, c_str))
}

// Given the name of a 'feature', return whether this ImageInput supports input of images
// with the given properties. Feature names that ImageIO plugins are expected to recognize
// include: none at this time.
// Note that main advantage of this approach, versus having separate individual supports_foo()
// methods, is that this allows future expansion of the set of possible queries without changing
// the API, adding new entry points, or breaking linkage compatibility.
func (i *ImageInput) Supports(feature string) bool {
	c_str := C.CString(feature)
	defer C.free(unsafe.Pointer(c_str))
	return bool(C.ImageInput_supports(i.ptr, c_str))
}

// Return a reference to the image format specification of the current subimage/MIPlevel.
// Note that the contents of the spec are invalid before Open() or after Close(), and may
// change with a call to SeekSubImage().
func (i *ImageInput) Spec() (*ImageSpec, error) {
	ptr := C.ImageInput_spec(i.ptr)
	return newImageSpec(ptr), i.LastError()
}

// func (i *ImageInput) ReadImage() ([]float32, error) {

// }
