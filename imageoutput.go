package oiio

/*
#include "stdlib.h"

#include "cpp/oiio.h"

*/
import "C"

import (
	"errors"
	"runtime"
	"unsafe"
)

type OpenMode int

// Constants defining the mode for which an ImageOutput should be opened
const (
	OpenModeCreate         OpenMode = C.Create
	OpenModeAppendSubimage OpenMode = C.AppendSubimage
	OpenModeAppendMIPLevel OpenMode = C.AppendMIPLevel
)

// ImageOutput abstracts the writing of an image file in a file format-agnostic manner.
type ImageOutput struct {
	ptr unsafe.Pointer
}

func newImageOutput(i unsafe.Pointer) *ImageOutput {
	out := &ImageOutput{i}
	runtime.SetFinalizer(out, deleteImageOutput)
	return out
}

func deleteImageOutput(i *ImageOutput) {
	if i.ptr != nil {
		C.free(i.ptr)
		i.ptr = nil
	}
}

// Create an ImageOutput that will write to a file, with the format
// inferred from the extension of the name. This just creates the ImageOutput, it
// does not open the file.
func CreateImageOutput(filename string) (*ImageOutput, error) {
	c_str := C.CString(filename)
	defer C.free(unsafe.Pointer(c_str))

	c_empty := C.CString("")
	defer C.free(unsafe.Pointer(c_empty))

	ptr := C.ImageOutput_Create(c_str, c_empty)
	out := newImageOutput(ptr)
	return out, out.LastError()
}

// Return the last error generated by API calls.
// An nil error will be returned if no error has occured.
func (i *ImageOutput) LastError() error {
	err := C.GoString(C.ImageOutput_geterror(i.ptr))
	if err == "" {
		return nil
	}
	return errors.New(err)
}

// Open an output file with given name. Return true if the file was found and opened okay.
func (i *ImageOutput) Open(filename string, spec *ImageSpec, mode OpenMode) error {
	c_str := C.CString(filename)
	defer C.free(unsafe.Pointer(c_str))

	ok := C.bool(C.ImageOutput_open(i.ptr, c_str, spec.ptr, C.OpenMode(mode)))
	if !ok {
		return i.LastError()
	}
	return nil
}

// Close an output image that we are totally done with.
func (i *ImageOutput) Close() error {
	if !bool(C.ImageOutput_close(i.ptr)) {
		return i.LastError()
	}
	return nil
}

// Return the name of the format implemented by this image.
func (i *ImageOutput) FormatName() string {
	return C.GoString(C.ImageOutput_format_name(i.ptr))
}

// Return a reference to the image format specification of the current subimage.
// Note that the contents of the spec are invalid before Open() or after Close().
func (i *ImageOutput) Spec() (*ImageSpec, error) {
	ptr := C.ImageOutput_spec(i.ptr)
	err := i.LastError()
	if err != nil {
		return nil, err
	}
	return &ImageSpec{ptr}, nil
}

// Given the name of a 'feature', return whether this ImageOutput
// supports output of images with the given properties.
// Feature names that ImageIO plugins are expected to recognize
// include:
//    "tiles"          Is this format able to write tiled images?
//    "rectangles"     Does this plugin accept arbitrary rectangular
//                       pixel regions, not necessarily aligned to
//                       scanlines or tiles?
//    "random_access"  May tiles or scanlines be written in
//                       any order (false indicates that they MUST
//                       be in successive order).
//    "multiimage"     Does this format support multiple subimages
//                       within a file?
//    "appendsubimage" Does this format support adding subimages one at
//                       a time through open(name,spec,AppendSubimage)?
//                       If not, then open(name,subimages,specs) must
//                       be used instead.
//    "mipmap"         Does this format support multiple resolutions
//                       for an image/subimage?
//    "volumes"        Does this format support "3D" pixel arrays?
//    "rewrite"        May the same scanline or tile be sent more than
//                       once?  (Generally, this will be true for
//                       plugins that implement interactive display.)
//    "empty"          Does this plugin support passing a NULL data
//                       pointer to write_scanline or write_tile to
//                       indicate that the entire data block is zero?
//    "channelformats" Does the plugin/format support per-channel
//                       data formats?
//    "displaywindow"  Does the format support display ("full") windows
//                        distinct from the pixel data window?
//    "origin"         Does the format support a nonzero x,y,z
//                        origin of the pixel data window?
//    "negativeorigin" Does the format support negative x,y,z
//                        and full_{x,y,z} origin values?
//    "deepdata"       Deep (multi-sample per pixel) data
//
// Note that main advantage of this approach, versus having
// separate individual supports_foo() methods, is that this allows
// future expansion of the set of possible queries without changing
// the API, adding new entry points, or breaking linkage
// compatibility.
func (i *ImageOutput) Supports(feature string) bool {
	c_str := C.CString(feature)
	defer C.free(unsafe.Pointer(c_str))
	return bool(C.ImageOutput_supports(i.ptr, c_str))
}

// Write the entire image of spec.Width x spec.Height x spec.Depth
// pixels, in the desired format.
// Depending on spec, write either all tiles or all scanlines.
// Assume that data points to a layout in row-major order.
// If format is TypeDesc UNKNOWN, then rather than converting from
// format, it will just copy pixels in the file's native data layout
// (including, possibly, per-channel data formats).
// Because this may be an expensive operation, a progress callback
// may be passed.  Periodically, it will be called as follows:
//   progress_callback (progress_callback_data ProgressCallback, done float)
// where 'done' gives the portion of the image
func (i *ImageOutput) WriteImageFormat(pixelData interface{}, format TypeDesc, progress *ProgressCallback) error {
	pixels_ptr, err := pixelsToPtr(pixelData)
	if err != nil {
		return err
	}

	var cbk unsafe.Pointer = nil
	if progress != nil {
		cbk = unsafe.Pointer(progress)
	}

	ok := bool(C.ImageOutput_write_image(i.ptr, C.TypeDesc(format), pixels_ptr, cbk))
	if !ok {
		return i.LastError()
	}

	return nil
}
